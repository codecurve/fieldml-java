<fieldml>
  <!--
    Produced by OpenCMISS, using the LaplaceExample project with a 4x4x0 mesh computed by 2 nodes. This file
    represents the first node's output.
   -->
   
  <cm_meta:opencmiss_annotation xmlns:cm_meta="http://www.fieldml.org/metadata/opencmiss_annotation/1.0">
    <cm_meta:region name="region1">
      <cm_meta:elements domain="mesh.element" node_map="element.nodes"/>
      <cm_meta:nodes domain="mesh.node" parameter_map="node.parameters"/>
      <cm_meta:mesh name="mesh.coordinates" type="quad" interpolation_map="element.phi_field" component_1="x" component_2="y" />
      <cm_meta:field name="mesh.g" type="scalar" mesh="mesh.coordinates" interpolation="element.phi_field" component_1="g" />
      <cm_meta:field name="mesh.n" type="scalar" mesh="mesh.coordinates" interpolation="element.phi_field" compoennt_1="n" />
    </cm_meta:region>
  </cm_meta:opencmiss_annotation>

  <discrete_domain id="node.field_phis" type="field">
    <import_component id="x" domain="library::phi_fields" component="phi" />
    <import_component id="y" domain="library::phi_fields" component="phi" />
    <import_component id="g" domain="library::phi_fields" component="phi" />
    <import_component id="n" domain="library::phi_fields" component="phi" />
  </discrete_domain>

  <continuous_domain id="node.parameters">
    <component id="x" />
    <component id="y" />
    <component id="g" />
    <component id="n" />
  </continuous_domain>
  
  <!--
    Mapped fields can only import components from other mapped fields with the same
    index domain.
    
    These maps are for extracting interpolation-specific values from the list of parameters
    attached to each node.
   -->
  <mapped_field id="node.parameters.bilinear_x" value_domain="library::bilinear_node_parameters">
    <mapping domain="mesh.node" component="id" />
    
    <import_component id="u" field="node.parameters" component="x" />
  </mapped_field>

  <mapped_field id="node.parameters.bilinear_y" value_domain="library::bilinear_node_parameters">
    <mapping domain="mesh.node" component="id" />
    
    <import_component id="u" field="node.parameters" component="y" />
  </mapped_field>

  <mapped_field id="node.parameters.bilinear_g" value_domain="library::bilinear_node_parameters">
    <mapping domain="mesh.node" component="id" />
    
    <import_component id="u" field="node.parameters" component="g" />
  </mapped_field>

  <mapped_field id="node.parameters.bilinear_n" value_domain="library::bilinear_node_parameters">
    <mapping domain="mesh.node" component="id" />
    
    <import_component id="u" field="node.parameters" component="n" />
  </mapped_field>
  
  <discrete_domain id="node.field_dofs" type="field">
    <component id="x">
      node.parameters.bilinear_x  <!--  node.parameters.bicubic_hermite_x -->
    </component>
    <component id="y">
      node.parameters.bilinear_y
    </component>
    <component id="g">
      node.parameters.bilinear_g
    </component>
    <component id="n">
      node.parameters.bilinear_n
    </component>
  </discrete_domain>
  
<!-- 
  <mapped_field id="node.parameters.bicubic_hermite_x" value_domain="library::bicubic_hermite_node_parameters">
    <mapping domain="mesh.node" component="id" />
    
    <import_component id="u" field="node.parameters" component="x" />
    <import_component id="duds1" field="node.parameters" component="dxds1" />
    <import_component id="duds2" field="node.parameters" component="dxds2" />
    <import_component id="d2uds1ds2" field="node.parameters" component="d2xds1ds2" />
  </mapped_field>
 -->  

  <discrete_domain id="mesh.element" type="index">
    <component id="id">
      3  4  7  8  11  12  15  16
    </component>
  </discrete_domain>
  
  <discrete_domain id="mesh.node" type="index">
    <component id="id">
      3  4  5  8  9  10  14  15  19  20  24  25
    </component>
  </discrete_domain>
  
  <discrete_domain id="mesh.element_nodes" type="index">
    <import_component id="node1" domain="mesh.node" component="id" />
    <import_component id="node2" domain="mesh.node" component="id" />
    <import_component id="node3" domain="mesh.node" component="id" />
    <import_component id="node4" domain="mesh.node" component="id" />
  </discrete_domain>
  
  <computed_field id="mesh.coordinates" value_domain="library::cartesian_2d">
    <parameter name="element" domain="mesh.element" />

    <!--
      An interpolate_component declaration uses the given node lists, dof map and
      phi map to interpolated the field. The number of components for any given
      entry in the dof map must match the number of components in the corresponding
      phi map entry. This can be checked by an offline validator if needed.
     -->
    <interpolate_component id="x">
      <nodes element_parameter="element" node_map="element.nodes" />
      <dofs dof_component="x" dof_map="node.dof_field" />
      <phis phi_component="x" phi_map="element.phi_field" />
    </interpolate_component>
    <interpolate_component id="y">
      <nodes element_parameter="element" node_map="element.nodes" />
      <dofs dof_component="y" dof_map="node.dof_field" />
      <phis phi_component="y" phi_map="element.phi_field" />
    </interpolate_component>
  </computed_field>

  <computed_field id="mesh.g" value_domain="library::infinite_line">
    <parameter name="element" domain="mesh.element" />

    <interpolate_component id="g">
      <nodes element_parameter="element" node_map="element.nodes" />
      <dofs dof_component="g" dof_map="node.dof_field" />
      <phis phi_component="g" phi_map="element.phi_field" />
    </interpolate_component>
  </computed_field>
  
  <computed_field id="mesh.n" value_domain="library::infinite_line">
    <parameter name="element" domain="mesh.element" />

    <interpolate_component id="n">
      <nodes element_parameter="element" node_map="element.nodes" />
      <dofs dof_component="n" dof_map="node.dof_field" />
      <phis phi_component="n" phi_map="element.phi_field" />
    </interpolate_component>
  </computed_field>
  
  <mapped_field id="node.parameters" value_domain="node.parameters">
    <mapping domain="mesh.node" component="id" />

    <map value="3">
      1.0000000000000000E+00   0.0000000000000000E+00   3.1972356254077172E+00  -5.3524942944527254E-07
    </map>
    <map value="4">
      1.5000000000000000E+00   0.0000000000000000E+00   3.6365212588612064E+00  -5.3524942966731714E-07
    </map>
    <map value="5">
      2.0000000000000000E+00   0.0000000000000000E+00   3.8050656639529055E+00   9.1764340634819641E-02
    </map>
    <map value="8">
      1.0000000000000000E+00   2.5000000000000000E-01   3.2333119188635906E+00  -4.6824431862851323E-01
    </map>
    <map value="9">
      1.5000000000000000E+00   2.5000000000000000E-01   3.6624772699266712E+00  -4.6824431862851257E-01
    </map>
    <map value="10">
      2.0000000000000000E+00   2.5000000000000000E-01   3.8587585611294335E+00  -5.7325184862691669E-01
    </map>
    <map value="14">
      1.5000000000000000E+00   5.0000000000000000E-01   3.7541981649838512E+00  -4.6824431862851390E-01
    </map>
    <map value="15">
      2.0000000000000000E+00   5.0000000000000000E-01   4.0337189461891123E+00  -5.7325184862691603E-01
    </map>
    <map value="19">
      1.5000000000000000E+00   7.5000000000000000E-01   3.8640888796308559E+00  -4.6824431862851279E-01
    </map>
    <map value="20">
      2.0000000000000000E+00   7.5000000000000000E-01   4.4352922105181323E+00  -5.7325184862691669E-01
    </map>
    <map value="24">
      1.5000000000000000E+00   1.0000000000000000E+00   3.7494245949541605E+00   1.2590685730495488E-01
    </map>
    <map value="25">
      2.0000000000000000E+00   1.0000000000000000E+00   5.4868641978000836E+00  -1.2488136854377663E-01
    </map>
  </mapped_field>


  <!--
    It seems that fields defined over a discrete domain only need to be defined over a single
    domain, which in turn has a single component. While this prohibits 'nesting' value
    requirements (i.e. forcing the field to be a single-parameter field), it simplifies the
    associated API greatly. For a start, it allows the api to infer "domain 1, component 1"
    for assigning values.   
   -->
  <mapped_field id="element.nodes" value_domain="mesh.element_nodes">
    <!--
      Perhaps just fold these into the mapped_field tag? 
     -->
    <mapping_parameter domain="mesh.element" component="id"/>
    
    <map value="3">
        3  4  8  9
    </map>
    <map value="4">
        4  5  9  10
    </map>
    <map value="7">
        8  9  13  14
    </map>
    <map value="8">
        9  10  14  15
    </map>
    <map value="11">
        13  14  18  19
    </map>
    <map value="12">
        14  15  19  20
    </map>
    <map value="15">
        18  19  23  24
    </map>
    <map value="16">
        19  20  24  25
    </map>
  </mapped_field>
  
  <mapped_field id="node.dof_field" value_domain="node.field_dofs">
    <mapping_parameter domain="mesh.node" component="id"/>

    <default_map>
      node.parameters.bilinear_x  node.parameters.bilinear_y  node.parameters.bilinear_g  node.parameters.bilinear_n
    </default_map>
  </mapped_field>

  <mapped_field id="element.phi_field" value_domain="node.field_phis">
    <mapping_parameter domain="mesh.element" component="id"/>

    <default_map>
      library::bilinear_lagrange_phi  library::bilinear_lagrange_phi  library::bilinear_lagrange_phi  library::bilinear_lagrange_phi
    </default_map>
  </mapped_field>
</fieldml>
